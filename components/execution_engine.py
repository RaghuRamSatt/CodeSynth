"""
Execution Engine - Safely executes generated Python code in a sandbox environment
"""

import io
import sys
import os
import logging
import time
import traceback
import contextlib
import resource
from typing import Dict, Any, Tuple, Optional, List
import pandas as pd
import matplotlib.pyplot as plt
import base64
from io import StringIO, BytesIO

# Configure logging
logger = logging.getLogger(__name__)

class ExecutionEngine:
    """
    Responsible for safely executing Python code generated by LLM models.
    Implements sandbox restrictions and resource limits to prevent abuse.
    """
    
    def __init__(self, config_path: str = "config/config.yaml"):
        """
        Initialize the execution engine with configuration settings.
        
        Args:
            config_path: Path to the configuration file
        """
        import yaml
        
        # Load configuration
        with open(config_path, 'r') as file:
            config = yaml.safe_load(file)
            
        self.config = config.get("execution_engine", {})
        self.timeout = self.config.get("timeout", 30)  # Default 30 seconds
        self.max_memory_mb = self.config.get("max_memory_mb", 1024)  # Default 1GB
        self.allowed_libraries = self.config.get("allowed_libraries", [
            "pandas", "numpy", "matplotlib", "seaborn", "plotly", 
            "scikit-learn", "scipy", "statsmodels"
        ])
        
        # Create a dictionary of pre-imported libraries
        self.preloaded_libs = self._preload_libraries()
        
    def _preload_libraries(self) -> Dict[str, Any]:
        """
        Preload allowed libraries to make them available in the sandbox.
        
        Returns:
            Dictionary mapping library names to imported modules
        """
        libs = {}
        
        for lib_name in self.allowed_libraries:
            try:
                if lib_name == "pandas":
                    import pandas as pd
                    libs["pd"] = pd
                    libs["pandas"] = pd
                elif lib_name == "numpy":
                    import numpy as np
                    libs["np"] = np
                    libs["numpy"] = np
                elif lib_name == "matplotlib":
                    import matplotlib
                    import matplotlib.pyplot as plt
                    # Use Agg backend to prevent display issues
                    matplotlib.use('Agg')
                    libs["plt"] = plt
                    libs["matplotlib"] = matplotlib
                elif lib_name == "seaborn":
                    import seaborn as sns
                    libs["sns"] = sns
                    libs["seaborn"] = sns
                elif lib_name == "plotly":
                    import plotly.express as px
                    import plotly.graph_objects as go
                    libs["px"] = px
                    libs["go"] = go
                elif lib_name == "scikit-learn":
                    import sklearn
                    libs["sklearn"] = sklearn
                elif lib_name == "scipy":
                    import scipy
                    libs["scipy"] = scipy
                elif lib_name == "statsmodels":
                    import statsmodels.api as sm
                    libs["sm"] = sm
                
                logger.info(f"Preloaded library: {lib_name}")
            except ImportError as e:
                logger.warning(f"Failed to preload library {lib_name}: {e}")
                
        return libs
        
    def execute_code(self, code: str, dataset_path: Optional[str] = None) -> Dict[str, Any]:
        """
        Execute the provided Python code safely in a sandbox environment.
        
        Args:
            code: Python code to execute
            dataset_path: Path to dataset file (optional)
            
        Returns:
            Dictionary containing execution results, including:
            - success: Boolean indicating if execution was successful
            - output: Text output from code execution
            - error: Error message if execution failed
            - figures: List of base64-encoded matplotlib figures
            - execution_time: Time taken to execute the code in seconds
        """
        # Initialize result dictionary
        result = {
            "success": False,
            "output": "",
            "error": "",
            "figures": [],
            "execution_time": 0
        }
        
        # Set up output capture
        output_buffer = StringIO()
        
        # Prepare the execution environment
        exec_globals = {
            **self.preloaded_libs,
            "__builtins__": __builtins__,
            "print": lambda *args, **kwargs: print(*args, file=output_buffer, **kwargs),
            "dataset_path": dataset_path
        }
        
        # If a dataset is provided, try to load it
        if dataset_path and os.path.exists(dataset_path):
            try:
                if dataset_path.endswith(".csv"):
                    df = pd.read_csv(dataset_path)
                elif dataset_path.endswith((".xls", ".xlsx")):
                    df = pd.read_excel(dataset_path)
                elif dataset_path.endswith(".json"):
                    df = pd.read_json(dataset_path)
                else:
                    df = None
                    result["error"] += f"Unsupported dataset format: {dataset_path}\n"
                
                if df is not None:
                    exec_globals["df"] = df
            except Exception as e:
                result["error"] += f"Error loading dataset: {str(e)}\n"
        
        # Add code to capture matplotlib figures
        code = """
import matplotlib.pyplot as plt
import io
import base64
from io import BytesIO

# Store original plt.figure function
_original_figure = plt.figure

# List to store figure references
_figures = []

# Override plt.figure to track figures
def _custom_figure(*args, **kwargs):
    fig = _original_figure(*args, **kwargs)
    _figures.append(fig)
    return fig

plt.figure = _custom_figure

# Function to get base64 encoded figures
def _get_figures_as_base64():
    results = []
    for fig in _figures:
        buf = BytesIO()
        fig.savefig(buf, format='png')
        buf.seek(0)
        img_str = base64.b64encode(buf.read()).decode('utf-8')
        results.append(img_str)
    return results

""" + code
        
        # Add code to get figures at the end
        code += """

# Capture all figures that were created
_captured_figures = _get_figures_as_base64()
"""
        
        # Initialize sandbox and resource limits
        start_time = time.time()
        
        try:
            # Set resource limits
            resource.setrlimit(resource.RLIMIT_CPU, (self.timeout, self.timeout))
            resource.setrlimit(resource.RLIMIT_AS, (self.max_memory_mb * 1024 * 1024, 
                                                   self.max_memory_mb * 1024 * 1024))
            
            # Execute the code
            with contextlib.redirect_stdout(output_buffer):
                with contextlib.redirect_stderr(output_buffer):
                    exec(code, exec_globals)
            
            # Mark as successful
            result["success"] = True
            
            # Get captured figures
            if "_captured_figures" in exec_globals:
                result["figures"] = exec_globals["_captured_figures"]
                
        except Exception as e:
            result["success"] = False
            result["error"] = f"{type(e).__name__}: {str(e)}\n{traceback.format_exc()}"
            
        finally:
            # Record execution time
            result["execution_time"] = time.time() - start_time
            
            # Get output
            result["output"] = output_buffer.getvalue()
            
        return result

class MLSandbox:
    """
    Specialized sandbox for machine learning code execution.
    Implements additional safety measures for ML-specific operations.
    """
    
    def __init__(self, execution_engine: ExecutionEngine):
        """
        Initialize the ML sandbox with an execution engine.
        
        Args:
            execution_engine: ExecutionEngine instance for code execution
        """
        self.execution_engine = execution_engine
        
    def run_analysis(self, code: str, dataset_path: str) -> Dict[str, Any]:
        """
        Run data science analysis code in the sandbox.
        
        Args:
            code: Python code to execute
            dataset_path: Path to dataset file
            
        Returns:
            Results from code execution
        """

        # Check if this is an error message (not actual code)
        if code.startswith("Error:"):
            return {
                "success": False,
                "output": "",
                "error": code,  # Return the error message directly
                "figures": [],
                "execution_time": 0
            }
        
        # Analyze code for potential issues before execution
        safety_check = self._check_code_safety(code)
        
        if not safety_check["safe"]:
            return {
                "success": False,
                "output": "",
                "error": f"Safety check failed: {safety_check['reason']}",
                "figures": [],
                "execution_time": 0
            }
            
        # Execute the code
        results = self.execution_engine.execute_code(code, dataset_path)
        
        # Add extra ML-specific post-processing here if needed
        # For example, checking model sizes, saving models, etc.
        
        return results
        
    def _check_code_safety(self, code: str) -> Dict[str, Any]:
        """
        Check if the code is safe to execute.
        
        Args:
            code: Python code to check
            
        Returns:
            Dictionary indicating if code is safe and reason if not
        """
        result = {"safe": True, "reason": ""}
        
        # List of dangerous operations to check for
        dangerous_patterns = [
            "os.system", "subprocess", "exec(", "eval(", 
            "import os", "import subprocess", "from os import", 
            "__import__", "open(", "file(", "pickle.loads", 
            "os.popen", "os.execv", "os.spawn", "pty.spawn"
        ]
        
        # Check for dangerous operations
        for pattern in dangerous_patterns:
            if pattern in code:
                result["safe"] = False
                result["reason"] = f"Code contains potentially unsafe operation: {pattern}"
                return result
                
        # Check for network access attempts
        network_patterns = [
            "socket", "urllib", "requests", "http", "ftp", 
            "urlopen", "ftplib", "smtplib"
        ]
        
        for pattern in network_patterns:
            if pattern in code:
                result["safe"] = False
                result["reason"] = f"Code contains potential network access: {pattern}"
                return result
                
        return result